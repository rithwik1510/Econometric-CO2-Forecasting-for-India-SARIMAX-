# -*- coding: utf-8 -*-
"""Portfolio Project: Advanced CO2 Emissions Forecasting for India

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Hkt6hIkJ8lhUgRHRf6cxgUPEjRys2GEn
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import statsmodels.api as sm
from statsmodels.tsa.statespace.sarimax import SARIMAX
from sklearn.metrics import mean_squared_error
import warnings
from itertools import product

# Suppress warnings for a cleaner output
warnings.filterwarnings("ignore")

class CO2Forecaster:
    """
    A class to encapsulate the entire workflow for forecasting CO2 emissions
    using a SARIMAX model. It includes data preprocessing, hyperparameter tuning,
    model training, evaluation, and visualization.
    """
    def __init__(self, data):
        """
        Initializes the forecaster with historical data.

        Args:
            data (dict): A dictionary containing lists for 'Year', 'CO2_Emissions_kt',
                         'GDP_USD_Billion', and 'Population_Million'.
        """
        self.raw_data = data
        self.df_processed = None
        self.train_endog = None
        self.train_exog = None
        self.test_endog = None
        self.test_exog = None
        self.model_fit = None
        self.forecast_df = None
        self.best_order = None

    def preprocess_data(self):
        """
        Converts the raw data into a time-series DataFrame, handles missing years
        by interpolating, and splits the data into training and testing sets.
        """
        df = pd.DataFrame(self.raw_data)
        df['Year'] = pd.to_datetime(df['Year'], format='%Y')
        df = df.set_index('Year')

        # *** FIX APPLIED HERE ***
        # Use resample('AS') to create annual start frequency, which correctly
        # places existing data points. Then, interpolate the missing years.
        # This is a more robust method than reindexing for this use case.
        df_resampled = df.resample('AS').mean()
        self.df_processed = df_resampled.interpolate(method='linear')

        print("--- Data Preprocessing Complete ---")
        print("Historical data interpolated to create a continuous time series.")

        # Train-Test Split (e.g., use data up to 2019 for training, 2020-2022 for testing)
        split_date = '2019-12-31'
        train_df = self.df_processed.loc[self.df_processed.index <= split_date]
        test_df = self.df_processed.loc[self.df_processed.index > split_date]

        self.train_endog = train_df['CO2_Emissions_kt']
        self.train_exog = train_df[['GDP_USD_Billion', 'Population_Million']]
        self.test_endog = test_df['CO2_Emissions_kt']
        self.test_exog = test_df[['GDP_USD_Billion', 'Population_Million']]

        print(f"Training data: {len(self.train_endog)} years")
        print(f"Testing data: {len(self.test_endog)} years\n")

    def find_best_sarimax_order(self):
        """
        Performs a grid search to find the optimal (p, d, q) order for the
        SARIMAX model based on the Akaike Information Criterion (AIC).
        """
        print("--- Finding Optimal Model Parameters (Hyperparameter Tuning) ---")
        p = d = q = range(0, 3) # Define the range for p, d, q
        pdq = list(product(p, d, q))

        best_aic = float("inf")
        best_pdq = None

        for param in pdq:
            try:
                # Use a temporary model for grid search
                temp_model = SARIMAX(self.train_endog, exog=self.train_exog, order=param)
                results = temp_model.fit(disp=False)
                if results.aic < best_aic:
                    best_aic = results.aic
                    best_pdq = param
            except Exception as e:
                continue

        print(f"Best SARIMAX order (p,d,q): {best_pdq} with AIC: {best_aic:.2f}\n")
        self.best_order = best_pdq

    def train_and_evaluate(self):
        """
        Trains the SARIMAX model on the training data and evaluates its performance
        on the test data using Root Mean Squared Error (RMSE).
        """
        if self.best_order is None:
            raise ValueError("Best order must be found before training. Run find_best_sarimax_order().")

        print("--- Model Training and Evaluation ---")
        model = SARIMAX(self.train_endog, exog=self.train_exog, order=self.best_order)
        self.model_fit = model.fit(disp=False)

        print(self.model_fit.summary())

        # Evaluate on test set
        test_predictions = self.model_fit.get_forecast(steps=len(self.test_endog), exog=self.test_exog).predicted_mean
        rmse = np.sqrt(mean_squared_error(self.test_endog, test_predictions))
        print(f"\nModel Evaluation - RMSE on Test Set: {rmse:,.2f} (kt of CO2)\n")

        print("--- Generating Model Diagnostics ---")
        print("Close the diagnostic plot window to continue to the final forecast.")
        self.model_fit.plot_diagnostics(figsize=(15, 12))
        plt.suptitle("SARIMAX Model Diagnostics", fontsize=16, y=1.02)
        plt.tight_layout()
        plt.show()

    def forecast_future(self, future_steps=13):
        """
        Forecasts future emissions and creates a DataFrame with predictions
        and confidence intervals.

        Args:
            future_steps (int): Number of years to forecast into the future.
        """
        print("--- Forecasting Future Emissions ---")
        # Retrain the model on the full dataset for the best possible forecast
        full_model = SARIMAX(self.df_processed['CO2_Emissions_kt'],
                             exog=self.df_processed[['GDP_USD_Billion', 'Population_Million']],
                             order=self.best_order)
        full_model_fit = full_model.fit(disp=False)

        # Project future exogenous variables
        future_years = pd.date_range(start=self.df_processed.index[-1], periods=future_steps + 1, freq='AS')[1:]
        gdp_trend = self.df_processed['GDP_USD_Billion'].diff().mean()
        pop_trend = self.df_processed['Population_Million'].diff().mean()

        future_exog = pd.DataFrame(index=future_years)
        last_gdp = self.df_processed['GDP_USD_Billion'].iloc[-1]
        last_pop = self.df_processed['Population_Million'].iloc[-1]
        future_exog['GDP_USD_Billion'] = [last_gdp + gdp_trend * i for i in range(1, future_steps + 1)]
        future_exog['Population_Million'] = [last_pop + pop_trend * i for i in range(1, future_steps + 1)]

        # Get the forecast object from the retrained model
        forecast_obj = full_model_fit.get_forecast(steps=future_steps, exog=future_exog)

        self.forecast_df = pd.DataFrame({
            'Predicted_CO2_Emissions_kt': forecast_obj.predicted_mean.astype(int),
            'Lower_Confidence_Bound': forecast_obj.conf_int().iloc[:, 0].astype(int),
            'Upper_Confidence_Bound': forecast_obj.conf_int().iloc[:, 1].astype(int)
        })
        print("Predicted CO2 Emissions for India (2023-2035):")
        print(self.forecast_df)
        print("\n" + "="*50 + "\n")

    def plot_forecast(self):
        """
        Generates and displays the final plot showing historical data,
        model fit, test set evaluation, and future forecast.
        """
        plt.style.use('seaborn-v0_8-whitegrid')
        fig, ax = plt.subplots(figsize=(18, 9))

        # Plot historical data
        ax.plot(self.df_processed.index, self.df_processed['CO2_Emissions_kt'], label='Historical Emissions', color='black', marker='.', markersize=8)

        # Plot the fit on the training data
        fit_on_train = self.model_fit.get_prediction(start=self.train_endog.index[0], end=self.train_endog.index[-1], exog=self.train_exog).predicted_mean
        ax.plot(fit_on_train.index, fit_on_train, color='orange', linestyle='--', label='Model Fit on Training Data')

        # Plot actual test data and the forecast for the test period
        test_predictions = self.model_fit.get_forecast(steps=len(self.test_endog), exog=self.test_exog).predicted_mean
        ax.plot(self.test_endog.index, self.test_endog, label='Actual Test Data', color='blue', marker='o', linestyle='None', markersize=8)
        ax.plot(test_predictions.index, test_predictions, label='Test Set Forecast', color='green', linestyle='--', linewidth=2)

        # Plot future forecast
        ax.plot(self.forecast_df.index, self.forecast_df['Predicted_CO2_Emissions_kt'], label='Future Forecast', color='red', linestyle='--')
        ax.fill_between(self.forecast_df.index,
                        self.forecast_df['Lower_Confidence_Bound'],
                        self.forecast_df['Upper_Confidence_Bound'],
                        color='pink', alpha=0.6, label='95% Confidence Interval')

        # Formatting
        ax.set_title('India CO2 Emissions: Historical Data, Model Evaluation & Forecast', fontsize=20, weight='bold')
        ax.set_xlabel('Year', fontsize=14)
        ax.set_ylabel('CO2 Emissions (in Kilotons)', fontsize=14)
        ax.legend(loc='upper left', fontsize=10)
        ax.grid(True, which='both', linestyle='--', linewidth=0.5)
        ax.get_yaxis().set_major_formatter(plt.FuncFormatter(lambda x, p: f'{x:,.0f}'))

        plt.tight_layout()
        print("A plot has been generated to visualize the final results.")
        print("Please close the plot window to exit the script.")
        plt.show()

def main():
    """
    Main function to run the CO2 forecasting project.
    """
    historical_data = {
        'Year': [1990, 1995, 2000, 2005, 2010, 2015, 2018, 2019, 2020, 2021, 2022],
        'CO2_Emissions_kt': [605540, 816360, 992520, 1210460, 1795450, 2274760, 2599840, 2654350, 2449780, 2709680, 2830450],
        'GDP_USD_Billion': [316, 356, 468, 820, 1675, 2103, 2702, 2835, 2671, 3150, 3385],
        'Population_Million': [873, 963, 1056, 1147, 1234, 1310, 1352, 1366, 1380, 1393, 1407]
    }

    forecaster = CO2Forecaster(historical_data)
    forecaster.preprocess_data()
    forecaster.find_best_sarimax_order()
    forecaster.train_and_evaluate()
    forecaster.forecast_future()
    forecaster.plot_forecast()

if __name__ == '__main__':
    main()